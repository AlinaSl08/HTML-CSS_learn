# Способы подключения CSS

## Через внешний файл (link)

В head HTML-документа нужно добавить link со ссылкой на файл .css:
``` html  
<link rel="stylesheet" href="style.css">
```

## Через тэг “<style>”
В head HTML-документа нужно добавить тэг “style”:
``` html
<style>
 .example {
  background: #ebac0c;
 }
</style>
```
                  
## Через атрибут “style”
Чтобы стилизовать конкретный элемент, можно использовать атрибут “style”:
``` html
<div style="border: 1px solid #000; margin-top: 16px;">Див со стилем</div>
```
                  
Синтаксис внутри атрибута совпадает с синтаксисом внутри фигурных скобок в селекторе CSS.

# Синтаксис CSS
Синтаксис CSS состоит из двух частей: селекторы и свойства. Селекторами мы указываем элементы, а свойствами описываем их стиль.

## Селекторы
Селектор это правило, по которому будут выбраны элементы — например, мы можем обратиться ко всем параграфам или картинкам. 
```css
p {} img {}
```
                  
## Свойства
Свойства пишутся у конкретных селекторов между фигурными скобками в формате ключ: значение.

Вот пример как сделать у всех параграфов красный цвет и подчёркивание:
``` css
p {
 color: red;
 text-decoration: underline;
}
```
                  
+ Каждое новое свойство пишется с новой строки.
+ После каждого свойства необходимо ставить точку с зяпятой.

# Типы селекторов
Это основные типы селекторов. Есть и более сложные, но их очень редко используют даже опытные разработчики. Потому что один из главных принципов в написании кода - KISS.

Каждый селектор имеет свою специфичность – если стили в разных селекторах будут конфликтовать, применятся они будут в порядке специфичности – от более специфичному к менее специфичному.


## По тегу

Самый простой селектор - выбирает элементы по их тегу:
``` css
h1 {
   /* стили для всех h1 */
}
```
                  
Этот селектор выберет все элементы `<h1>`

## По классу

Самый часто используемый селектор — по классу. Задаём в HTML класс элементам, к которым применить стиль:

``` html
<div class="card">
 Карточка
</div>
```
                  
И теперь эти элементы можно выбрать по имени класса. Имя селектора начинается с точки:
``` css
.card {
   /* стили для всех элементов с class="card" */
   background: #333; /* фон серого цвета */
}
```
                  
## По id

Задавать стили по id - дурной тон, старайся его избегать. Тут всё тоже самое, что и с классом, только атрибут называется id:
``` html
<button id="button-go-to-top">
 Наверх
</button>
```
                  
**И имя селектора начинается с решётки:**

``` css
#button-go-to-top {
   /* стили для элемента с id="button-go-to-top" */
   text-decoration: underline; /* подчёркивание текста */
}
```
                  
## По атрибуту

Не самый популярный селектор, но иногда он полезен:
``` html
<button data-my-custom-attribute="my-custom-value">
 Нажми на меня
</button>
```
                  
Имя и значение атрибута пишется в квадратных скобках. Работает с любым атрибутом:

[data-my-custom-attribute="my-custom-value"] {
   color: red;
}


## Любой элемент

Селектор * выбирает абсолютно любой элемент. Самый непопулярный селектор, обычно используется для костылей. Вряд ли он будет часто тебе нужен. Просто знай, что он есть.
``` css
* {
  margin: 0;
}

/* абсолютно всем элементам будет установлен margin: 0 */
```

# Составные селекторы

Составные селекторы состоят из комбинации простых.

## Группировка селекторов

Один и тот же набор свойств можно применить к разным селекторам. Пример:
``` css
button,
.button,
.cta-button {}
```                

Нужно просто указать  через запятую все селекторы, к которым ты хочешь применить стили.

## Элемент с классом

Можно стилизовать конкретный элемент, если у него есть определённый класс. Примеры:
``` css
p.example {}
```
                  
Селектор выберет все p, у которых есть класс example.
``` css
.main.active {}
```
                  
Селектор выберет все элементы с классом main, у которых также есть и класс active. Пример такого элемента:
``` html
<div class="main active">Пример</div>
```

# Вложенность

Эти селекторы используются для выбора элементов, которые вложены в другие элементы.

## Вложенность на любом уровне

**Если между двумя простыми селекторами стоит пробел и ничего больше, это означает вложенность на любом уровне.** 

Пример:
``` css
.page p {
 text-decoration: underline;
}
```
                  
Этот селектор применит подчёркиваение ко всем `<p>`, которые находятся внутри элемента с классом page на любом уровне вложенности.
``` html
<div class="page">
 <p>Как писал Пелевин:</p>
 <div class="quote">
  <p>
   Человек привык видеть дьявола везде, кроме зеркала и телевизора.
  </p>
 </div>
</div>
```
                  
Результат:
![](https://ucarecdn.com/ab938643-e1ae-44f2-b400-06b7f4f40818/)

## Вложенность на первом уровне

Правая угловая скобка > обозначает вложенность на первом уровне. Пример:
``` css
.page > p {
 text-decoration: underline;
}
```
                  
Этот селектор применится ко всем `<p>`, которые находятся внутри элемента с классом page на первом уровне вложенности.

Для HTML из предыдущего примера:
![](https://ucarecdn.com/d281f319-ceb4-4e40-a63a-2509373c92f3/)

# Составные селекторы
Селекторы, которые идут дальше, используются редко.  

## Элементы с определенным атрибутом

``` css 
 input[type="password"] {}
```
                  
﻿Этот селектор выберет все элементы `<input type="password">`
 
## Первый соседний элемент

Для того, чтобы выбрать элемент, который находится сразу после другого элемента, используется знак `+`. Пример:
``` css
img + p {
 margin-top: 0;
 font-style: italic;
}
```
                  
Этот код применит стили во всех `<p>`, идущих **сразу после** `<img>`:
``` css
<img src="https://www.google.ru/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" />
<p>Это лого гугла</p>
<p>А это просто абзац</p>
```

## Любой соседний элемент

Для того, чтобы выбрать элемент, который находится после другого элемента, используется знак `~`. Пример:
``` css
img ~ p {
 margin-top: 0;
 font-style: italic;
}
```
                  
Этот код применит стили во всех `<p>`, идущих **после** `<img>`, даже если между img и p есть **другие элементы**.

# Фон
В CSS блокам можно задавать фон. Фоном может быть цвет или картинка. Картинку можно располагать с помощью координат, центрировать, растягивать на весь блок, или задавать в виде повторяющегося бесконечного паттерна. Всё это делается с помощью свойства **background**, подробнее про него здесь: https://webref.ru/css/background, обрати внимание на блоки «См. также» и «Рецепты».

Примеры:
``` css
.example {
   /* цвет фона «продающий красный», задан в HEX-формате */
   background: #e64c0c;
}

.example {
   /* картинка на фоне */
   background: url('images/nude-president.png'); 

   /* background-size отвечает за размер картинки, cover - картинка растягивается на весь блок, сохраняя пропорции */
   background-size: cover;
}
```

# Цвет
Цвет можно ставить не только фону, но и тексту, границам, теням. Есть несколько способов указать цвет:

+ **Имя цвета** из списка HTML-цветов, например "red", "green", "blue" , "lemonchiffon".
+ **HEX**, цвет в шестнадцатеричном формате. Начинается с решётки, например #3ae6сa. Можно подобрать с помощью любого color picker'а. Первые шесть символов отвечают за цвет, последние два - необязательные - отвечают за прозрачность. Но прозрачность удобнее задавать через RGBA и HSLA, потому что десятичные дроби удобнее читать и редактировать.﻿
+ **RGB** (red, green, blue) - цвет, заданый тремя значениями (от 0 до 255) базовых цветов - красного, зелёного и синего. Пример: rbg(255, 123, 13).
+ **RGBA** - тоже самое, что и RGB, только с прозрачностью, которая задаётся четвёртым числом от 0 до 1, пример: rgba(144, 32, 16, 0.5).
+ **HSL, HSLA** - цветовая модель, в которой цветовыми координатами являются тон, насыщенность и светлота.
 HSLA - HSL + прозрачность. Пример: hsl(120, 100%, 50%).

# Тип отображения элемента (display)

Есть два типа элементов - блочные и строчные. Кратко: блочные элементы занимают всю доступную ширину и начинаются с новой строчки. Строчные занимают столько места по ширине, сколько занимает их содержимое, выстраиваются в одну строчку и переносятся, если им не хватает места.

С помощью CSS-свойства **display** можно переопределить тип отображения элемента. Оно может иметь одно из следующих значений.

+ **display: none;** - элемент перестаёт отображаться на странице.
+ **display: block;** - блочный элемент. Ему можно задать ширину, высоту, границы, отступы.
+ **display: inline;** - строчный элемент. Задание ширины и высоты не влияет на inline элементы. Задание границ и отступов будет изменять положение окружающего текста, но не будет влиять на положение окружающих блочных элементов.
+ **display: inline-block;** - что-то среднее между блочным и строчным элементом. Ему можно задать ширину, высоту, границы и отступы, но он не будет создавать перенос строки до и после себя, в отличие от блочных элементов. С помощью этого типа можно распологать блоки горизонтально в ряд.
+ **flex и inline-flex** - это флексбоксы. Про них расскажем в уроке «Flexbox» в модуле «Продвинутая вёрстка». Элементы внутри них располагаются по определённым правилам, но снаружи они ведут себя как блоки и инлайн-блоки соотвественно.

В дальнейшем элементы с display block, inline-block, flex и inline-flex мы будем называть просто **«блоки»**.

# Переполнение контента
Когда контент не вмещается в блок, происходит переполнение контента и в блоке появляется полоса прокрутки. 
![](https://ucarecdn.com/a5851d08-0f44-4167-bc92-806ff1e5a7da/)
Свойство overflow управляет отображением содержания блочного элемента при переполнении.

## Значения overflow
+ **overflow: visible;** - отображается все содержание блока, даже за пределами установленной высоты и ширины.

![](https://ucarecdn.com/085fcb41-2618-4dec-9e54-71003e325e02/) 

+ **overflow: hidden;** - отображается только область внутри блока, остальное будет скрыто.

![](https://ucarecdn.com/6249e54b-25b3-449b-acdc-c21af20b6e50/) 

+ **overflow: scroll;** - всегда добавляются полосы прокрутки, даже если контент помещается.

![](https://ucarecdn.com/5f439e4c-8072-4799-9c30-dd2bbb712179/) 

+ **overflow: auto;** - полосы прокрутки добавляются только при необходимости.

![](https://ucarecdn.com/59857a2c-a08b-4b0c-87fc-bb6d28eaf57a/-/crop/455x110/0,0/-/preview/) 

# Обтекание элементов (float)
Свойство `float` может иметь следующие значения:

+ **left** - выравнивание по левой стороне, обтекание справа,
+ **right**  - выравнивание по правой стороне, обтекание слева,
+ **none** - выравнивание не задаётся (нужно, чтобы сбросить ранее заданное значение).

# Clearfix
При использовании свойства `float`, новички испытывают проблемы. И все они вызваны нелогичным принципом работы float. Рассмотрим несколько проблем и попытаемся их решить.

## Проблема 1
Родительский блок, который содержит только элементы со свойством float, "схлопывается" и принимает высоту равную нулю.
Пример: 

![](https://ucarecdn.com/3bad9ef4-646b-490f-998b-e0beadd4bbca/)


## Проблема 2
Если в родительском блоке помимо "плавающих" (floating) элементов есть статические элементы, к которым мы не применяли float, то высота родителя станет равной высоте этих статических элементов. Пример: 

![](https://ucarecdn.com/d9d3eb22-4c08-467c-9741-a1cadcd0df5d/)


## Проблема 3
Следствие проблемы 2. Такие "вываливающиеся" блоки будут обтекаться контентом блоков, которые идут после родительского. Пример: 

 ![](https://ucarecdn.com/46d169f7-9629-41b8-bdd3-ab9b1beace6e/)

## Решение
Чтобы избавиться от этих проблем, необходимо после "плавающих" блоков очищать обтекания, чтобы последующие элементы не стали обтекать "плавающие" блоки.

Самое простое решение - очищающий блок. После плавающих блоков нужно добавить еще один блок и задать ему CSS:
``` css
clear: both;
```
 Пример:                  

![](https://ucarecdn.com/edba6211-9055-47a5-84f5-1811913ff382/)
 

# Позиционирование
Позиционирование определяет, к какой части страницы элемент будет «прикреплён».

Тип позиционирования задаётся с помощью свойства `position`. Разберём типы позиционирования.

## Статическое позиционирование (static)
Этот тип стоит у элементов по умолчанию. Элемент располагается в потоке относительно остальных элементов на странице. В потоке, то есть в таком порядке, что он идёт после элементов, которые объявлены перед ним. И элементы, которые объявлены после него, идут после него.
``` html
<h1>Заголовок</h1>
<p>Абзац</p>
```

![](   https://ucarecdn.com/2776ddb2-47c2-40bc-87ff-1cd035afce06/)               


Вроде бы очевидно, что если заголовок объявлен раньше абзаца, то он будет под заголовком. Да? Да, но только для этого типа позиционирования.

## Абсолютное позиционирование (absolute)
Забавно, что абсолютное позиционирование - тоже относительное. Но задаётся оно по-другому.

**Положение абсолютного блока задаётся относительно страницы или относительно элемента с position: relative, в которой он вложен.** Положение такого блока задаётся с помощью свойств **top, right, bottom, left.**

Например, расположим абзац из примера выше вверху экрана.  Для HTML кода из примера выше:

![](https://ucarecdn.com/ffd26dc5-ee13-444d-958d-74f2f1cbe025/-/crop/163x83/0,0/-/preview/)


``` css

p {
  position: absolute;
  top: 0;
}
```
                  
Элементы со статическим позиционированием игнорируют абсолютные блоки, которые как бы "вываливаются" из потока и живут своей собственной жизнью. Как будто существуют на своём собственном слое. ﻿

## Фиксированное позиционирование (fixed)

Задаётся так же, как и абсолютное, но блок прикрепляется не к странице, а к экрану. То есть при прокрутке страницы он остаётся на своём месте. Пример - шапка на степике.

## Относительное позиционирование (position: relative)
Положение элемента устанавливается относительно его исходного места в потоке. Свойства **left, top, right и bottom** изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. А ещё оно работает как родитель, относительно которого можно задавать абсолютную позицию блокам, которые в него вложены.

# Flexbox

Значения для выравнивания и расположения
1. **`justify-content`** (выравнивание по главной оси):
   
+ **flex-start**: Элементы выравниваются по началу главной оси.
+ **flex-end**: Элементы выравниваются по концу главной оси.
+ **center**: Элементы располагаются в центре главной оси.
+ **space-between**: Пространство равномерно распределяется между элементами, крайние элементы прижимаются к краям контейнера.
+ **space-around**: Пространство равномерно распределяется вокруг каждого элемента, создавая одинаковые отступы с обеих сторон.
+ **space-evenly**: Пространство равномерно распределяется между всеми элементами и между элементами и краями контейнера.
  
2. **`align-items`** (выравнивание по поперечной оси):
   
+ **flex-start**: Выравнивает элементы по началу поперечной оси.
+ **flex-end**: Выравнивает элементы по концу поперечной оси.
+ **center**: Выравнивает элементы по центру поперечной оси.
+ **stretch** (по умолчанию): Растягивает элементы, чтобы они заполнили всю высоту поперечной оси.
+ **baseline**: Выравнивает элементы по их базовой линии текста.
  
## Значения для управления элементами
1. **`flex-direction`** (направление главной оси):
   
+ **row**: Элементы располагаются в одну строку (по умолчанию).
+ **row-reverse**: Элементы располагаются в строку в обратном порядке.
+ **column**: Элементы располагаются в один столбец.
+ **column-reverse**: Элементы располагаются в столбец в обратном порядке.
  
2. **`flex-wrap`** (перенос элементов):
+ **nowrap**: Все элементы остаются в одну строку, даже если они не помещаются.
+ **wrap**: Элементы переносятся на следующую строку, если не помещаются.
+ **wrap-reverse**: Элементы переносятся на следующую строку в обратном порядке. 

## Значения для отдельных флекс-элементов
+ **`flex-grow`**: Определяет, насколько элемент может растягиваться, если есть свободное пространство.
+ **`flex-shrink`**: Определяет, насколько элемент может сжиматься, если свободного пространства недостаточно.
+ **`flex-basis`**: Задает начальный размер элемента перед распределением свободного пространства. 

# Псевдоклассы

Псевдоклассы - это ключевые слова, которые добавляются к селектору. Стили, заданные таким образом, применяются только для определённых состояний. Например, :hover может быть использован для изменения цвета кнопки при наведении курсора:
``` css
button:hover {
   background: red;
}
```

Стили псевдокласса переопределяют заданные ранее стили, если они есть. Пример:
``` css
button {
  border: 1px solid black;
  padding: 8px 16px;
  background: #c9c9c9;
}

button:hover {
  background: #e9e9e9;
}
```


Самые часто используемые псевдоклассы:
+ `:hover` - появляется при наведении мышки
+ `:active` - появляется при нажатии на элемент
+ `:focus` - появляется при фокусировке на элементе (например, когда выбрано поле ввода текста)

# Анимация переходов
Переходы состояний некоторых в CSS можно анимировать. Это работает так: если значение свойства меняется, то вместо резкого изменения, происходит плавный переход.

![](https://ucarecdn.com/c3a2f204-e691-490d-8326-eef00ae8f4dc/)

Вот так выглядит анимирование переходов в коде:
``` css
button {
    border-radius: 4px;
    transition: border-radius 0.5s ease-in;
}

button:hover {
    border-radius: 16px;
}
```
                  

За анимацию отвечает свойство `transition`. Его значние записывается так:

+ свойство, изменения которого нужно анимировать (если нужно анимировать несколько, можно написать all)
+ продолжительность анимации в секундах (рекомендуется не ставить её больше 0.3 секунды)
+ функция плавности, подробнее здесь: https://easings.net/ru

# Медиа-запросы
Медиа-запросы позволяют задавать стили для определенных типов устройств, например, принтеры, экраны или синтезаторы речи.

Чаще всего они используются, чтобы создавать адаптивные страницы.

## Синтаксис
Синтаксис медиа-запроса выглядит так:
``` css
﻿@media правило {
   /* ﻿обычный CSS-код, который применится при соблюдении правила */
}
```
                  
﻿Пример медиа-запроса:
``` css
@media screen and (max-width: 320px) {
    img {
        width: 100%;
    }
}
```
                  
Этот код означает следующее: **на экранах, ширина** которых **меньше или равна 320px**, картинки будут иметь ширину 100%.
